# 计算机网络

## 五层模型

### 物理层

物理层的主要作用是通过光纤、电缆等介质连接计算机，通过高低电频发送 0 和 1 电信号。

### 数据链路层

数据链路层通过制定协议去规定电信号的传输和接收。

##### 以太网协议

以太网协议规定，一组电信号构成一个数据包，称为**帧**。

每一个帧由**标头**和**数据**组成，标头主要是一些说明数据，例如发送者和接收者的相关信息。数据则是发送者想要传输给接收者的数据包。

##### MAC 地址

每一个连入网络的计算机都有一个网卡，每一个网卡都有一个唯一的地址，这个地址就是**MAC 地址**。

MAC 地址由 48 个二进制位组成，在网卡生产时就已经确定了。

##### 广播

向同一子网内的计算机发送同一个数据包，所有接受该数据包的计算机比对 MAC 地址，如果相同则接收，否则丢弃。

### 网络层

##### IP 协议

IP 协议定义的地址称为 **IP 地址**，IPv4 的地址由 32 位二进制数组成。

IP 地址由两部分组成，分别是**网络部分**和**主机部分**，两部分所占用的二进制位数是不固定的。通过**子网掩码**与 IP 地址做与（and）运算可以得出网络部分，当网络部分相同时，即在同一个子网中。

##### ARP 协议

ARP 协议是一个根据 IP 地址获取 MAC 地址的一个 TCP/IP 协议。主机通过广播发送数据包，同一子网内的计算机接收数据包后比对 IP 地址，如果相同则把自己的 MAC 地址回复发送者。

假如两台计算机的 IP 不在同一个子网中，则会把数据包发送到网关，让网关进行转发到别的子网。

**网络层的功能就是建立计算机到计算机的通信。**

### 传输层

传输层的功能就是**建立端口到端口的通信**，通过端口的准确将数据交给计算机中各种各样的应用程序。

### 应用层

虽然我们收到了传输层传来的数据，可是这些传过来的数据五花八门，有 html 格式的，有 mp4 格式的，各种各样。

因此我们需要指定这些数据的格式规则，收到后才好解读渲染。例如我们最常见的 Http 数据包中就会指定该数据包是什么格式的文件。

参考资料：

- [计算机网络五层模型入门](https://www.iamshuaidi.com/747.html)

## TCP

### 三次握手

握手之前客户端处于 `CLOSED` 状态，服务端处于 `LISTEN` 状态，然后开始三次握手：

1. 第一次握手：客户端发送一个 `SYN` 报文，并指定一个初始化序列号 a，此时客户端进入 `SYN_SEND` 状态。
2. 第二次握手：服务端收到客户端发送的 `SYN` 报文后，同样发送一个 `SYN` 报文作为应答，并指定一个初始化序列号 b，同时将 a + 1 作为 `ACK` 的值，表示自己已经收到了客户端的报文，此时服务端进入 `SYN_REVD` 状态。
3. 第三次握手：客户端收到服务端的 `SYN` 报文后，发送一个 `ACK` 报文作为应答，将 b + 1 作为 `ACK` 的值，表示已经收到了服务端的报文，此时客户端进入 `ESTABLISHED` 状态。

最后服务端收到 `ACK` 报文后也进入 `ESTABLISHED` 状态，此时双方建立连接完成。

**Q&A**

##### 1. 为什么不能是两次握手？

防止产生过时或无效的连接。

- **客户端请求报文延迟**：客户端发送请求后，由于网络堵塞等原因导致服务端没接收到该报文，此时客户端在规定时间内没有收到服务端的应答报文就会重新发送请求，服务端作出应答后正常建立连接，这时上一个请求报文到达服务端，服务端也会作出应答，导致客户端和服务端再次建立连接，导致不必要的错误和资源的浪费。
- **服务端应答报文丢失**：如果只有两次握手，在第二次握手中服务端发送的应答报文丢失了，由于没有第三次握手，服务端也不知道客户端是否收到应答报文，就会一直处于开启状态，而客户端由于没有收到应答报文会再次发送请求，那么服务端就会重新开启一个端口连接，而此时上一个端口一直处于开启状态但是并没有传输数据，就会造成服务端的资源浪费。

##### 2. 报文中的序列号是固定的吗？

序列号的作用是让对方知道接下来接收数据的时候如何按照序列号组装数据，如果是固定的则很容易被攻击者猜到后续的确认号，因此序列号是**动态生成**的。

### 四次挥手

挥手前双方都处于 `ESTABLISHED` 状态，当客户端主动发起结束连接请求时，挥手开始：

1. 第一次挥手：客户端发送一个 `FIN` 报文，并指定一个序列号 a，此时客户端处于 `FIN_WAIT1` 状态。
2. 第二次挥手：服务端收到 `FIN` 报文后，发送一个 `ACK` 报文作为应答，并指定 **a + 1** 作为 `ACK` 的值，此时服务端处于 `CLOSE_WAIT` 状态。
3. 第三次挥手：服务端发送一个 `FIN` 报文，并指定一个序列号 b ，此时服务端处于 `LAST_ACK` 阶段。
4. 第四次挥手：客户端收到报文后，同样发送一个 `ACK` 报文作为应答，并指定 **b + 1** 作为 `ACK` 的值，然后进入 `TIME_WAIT` 阶段，等待 **2MSL** 时间后进入 `CLOSED` 阶段。

服务端收到 `ACK` 报文后就进入 `CLOSED` 状态，结束连接。

**Q&A**

1. 为什么 `TIME_WAIT` 状态要持续 2MSL？

MSL（Maximum Segment Lifetime）是**最大报文生存时间**，即报文在网络传输时的超时时间，超时的报文会被丢弃。

`TIME_WAIT` 状态要持续 2MSL 是因为在第四次挥手中客户端发送 ACK 报文后，如果服务端在第一个 MSL 没收到 ACK 报文，就会重新发送 FIN 报文，第二个 MSL 则是 FIN 报文到达客户端的最长时间，如果在这个时间内客户端没有收到 FIN 报文，表示服务端已经收到客户端的 ACK 报文，所以经过 2MSL 后客户端可以进入 `CLOSED` 状态。

参考资料：

- [三次握手与四次挥手](https://juejin.cn/post/6844903834708344840)

## HTTP

**`HTTP` 是一个在计算机世界里专门在两点之间传输文字、图片、音频和视频等超文本数据的约定和规范。**

### HTTP 各版本特点

#### HTTP 0.9

- 只有 GET 命令
- 只能传输 html

#### HTTP 1.0

- 无状态、短连接（1.1 解决）
- 队头阻塞（2.0 解决）
- 引入 POST 和 HEAD 命令
- 可以传输 html 以外的文件（content-type）
- 支持不同编码格式文件的传输（content-encoding）

##### http 层队头阻塞

队头阻塞是指服务端的每个响应必须得按顺序返回，一个体积很大的响应会阻塞后续所有相应的返回。在 http 2.0 通过多路复用解决了，但是仍然存在 TCP 层的队头阻塞。

##### TCP 层队头阻塞

当传输时其中一个数据包丢失后，TCP 层会发生阻塞并进行数据重传。

#### HTTP 1.1

- 持久连接（Connection: keep-alive）
- 请求管道化（Pipeline）
- 增加缓存处理（cache-control）
- 增加 Host 字段
- 断点传输（range）

##### 请求管道化

请求管道化即不需要等待上一个请求响应后再发送请求，但是响应还是会按照请求顺序返回，所以并没有解决队头阻塞问题。

![http请求管道化](../image/http%E7%AE%A1%E9%81%93%E5%8C%96.png)

##### Host 字段

在 http1.0 中认为每台服务器都绑定唯一一个 `IP` 地址，因此请求中没有传递主机名，1.1 新增的 `Host` 字段用于处理一个 `IP` 地址上有多个虚拟主机的情况。在请求头中新增 `Host` 字段用来指定服务器域名，有了 `Host` 字段，就可以在同一台服务器上搭建不同网站。

#### HTTP 2.0

- 二进制分帧
- 多路复用（一个 TCP 连接可以进行任意数量的 HTTP 请求）
- 头部压缩
- 服务器推送

##### 多路复用

多路复用是基于流传输的，一个完整的请求或响应称为一个消息，每个消息都被拆分成若干帧（`frame`）进行传输，每个帧在传输时属于一个流（`stream`），而一个连接中可以存在多个流，各个帧在流和连接上独立传输，到达之后根据帧的头部信息组装成消息。

##### 服务器推送

在浏览器刚请求 `html` 时，服务器可以将关联的 `js`、`css` 等静态资源主动发送给客户端，这样客户端就可以直接从本地加载这些资源，不用再向服务器发送请求。

#### HTTP 3.0(HTTP-over-QUIC)

- 解决了队头阻塞
- 连接迁移

##### 队头阻塞

`HTTP/2` 之所以存在队头阻塞，是因为所有流共享一个滑动窗口，而 `QUIC` 中**给每个流分配一个独立的滑动窗口，把丢包监测和重传逻辑放在了每个流上**。

##### 连接迁移

TCP 连接基于四元组：源 IP、源端口、目标 IP 和目标端口，只要其中一个发生变化，就需要重新建立连接，而 `QUIC` 的连接是基于 `Connection ID` 的，切换网络并不会改变 `Connection ID`，因此连接并没有断开。`QUIC` 能实现连接迁移的根本原因是底层使用 `UDP` 协议就是**面向无连接**的。

![http版本](../image/http%E5%90%84%E7%89%88%E6%9C%AC%E7%BB%84%E6%88%90.png)

### HTTPS

HTTPS 就是在 `HTTP` 的基础上，利用 `SSL/TSL` 去加密数据。

HTTPS 的目的有以下两个：

- 加密数据
- 验证服务器身份

#### 加密数据

两种加密方式：

- 对称加密：发送方和接收方都是用同一个密钥进行数据加密解密
- 非对称加密：发送方和接收方使用一对密钥，即公钥和私钥。一般公钥是可公开的，私钥是保密不可泄漏的。

##### 混合加密

HTTPS 采用的混合加密其实就是把对称加密的密钥使用非对称加密的方法去传递。

流程如下：

1. 客户端生成会话密钥（对称加密生成的密钥）
2. 利用公钥（非对称加密的公钥，由服务器生成并发送给客户端）加密之后传递给服务器
3. 服务器利用非对称加密的私钥进行解密得到会话密钥
4. 客户端和服务器使用同一个会话密钥进行数据加解密

#### 验证服务器身份

必要概念：

- 数字签名：数字签名由发送者将原文（部分关键数据）通过 `hash` 算法生成**消息摘要**，再通过私钥加密生成，并与原文一起发送给接收者。
- 数字证书：数字证书由数字证书认证机构（CA）颁发，包含证书颁发机构、证书有效期、证书所有者、公钥和签名等信息。

##### 数据被篡改怎么办

使用**数字签名**验证数据，客户端接收到服务器发过来的数字签名后：

1. 用服务器的**公钥**解密数字签名得到消息摘要
2. 用 `hash` 算法计算原文生成一个消息摘要

如果两个消息摘要一致，说明数据没有被篡改。

为防止客户端收到的服务器公钥被篡改，需要使用数字证书，校验数字证书流程如下：

1. 浏览器读取证书**颁发者信息**，与操作系统内置的受信任的证书发布机构对比，校验证书是否为合法机构颁发
2. 如果找不到，则说明证书是不可信任的；否则浏览器就会从操作系统中取出**颁发者的公钥**，然后对数字证书中的签名进行解密，得到消息摘要
3. 浏览器使用相同的 `hash` 算法根据证书内容计算出消息摘要，与解密签名得到的消息摘要对比，若一致说明证书合法，没有被冒充，此时浏览器就可以读取**证书中的公钥**用于后续加密

整个流程如下图所示：

![https原理](../image/https%E5%8E%9F%E7%90%86.jpg)

#### TLS 四次握手

TLS1.2 握手流程（DH 握手）如下图所示：

![TLS握手流程](<../image/TLS%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B(DH).jpg>)

1. 客户端向服务器发送随机数 `client_random`、TLS 版本和加密套件列表
2. 服务器收到后立即返回随机数 `server_random`、确定的加密方法和含公钥的证书
3. 同时服务器利用私钥根据 `client_random`、`server_random` 和 `server_params` 生成签名，与 `server_params`（DH 算法参数） 一起发送给客户端
4. 客户端接收后验证数字证书和签名，若通过，则将 `client_params`(DH 算法参数)发送给服务器
5. 客户端和服务器都有相同的 `client_params` 和 `server_params`，根据这两个参数利用 `ECDHE` 算法计算出 `pre_random`

现在客户端和服务器都拥有三个相同的凭证：`client_random`、`server_random` 和 `pre_random`，双方使用确定的加密方法混合这三个参数，生成最终密钥，用于后续数据加解密，即使用**对称加密**。

**`DH` 握手与 `RSA` 握手的区别在于 `RSA` 握手的 `pre_random` 由 `RSA` 算法生成并用证书中的公钥加密传输给服务器，而 `DH` 握手的 `pre_random` 是传递参数后双方根据参数生成**

### http 状态码

**2xx 响应成功**

- 200： OK

**重定向 3xx**

- 301 `Moved Permanently`（永久移动）：所请求的资源被永久的移动到一个新的 URI 上，新的 URI 会在响应头的 Location 中提供。
- 302 `Founded`（临时移动）：所请求的资源被临时移动到新的 URI 上，后续可能还会被移动。
- 304 `Not Modified`（未修改）：资源未发生改变，要求客户端使用缓存资源。

**客户端错误 4xx**

- 400 `Bad Request`（错误请求）：请求语法格式错误，服务器无法处理该请求
- 401 `Unauthorized`（未授权）：该请求需要用户验证。
- 403 `Forbidden`（禁止访问）：服务器拒绝执行该请求。
- 404 `Not Found`（未找到）：服务器未找到请求的资源。
- 405 `Method Not Allowed`（方法不允许）：所请求的资源不允许使用当前的请求方法。

**服务器错误 5xx**

- 500 `Interval Server Error`：服务器在响应请求时发生错误。
- 502 `Bad Gateway`：服务器在充当网关或代理时，尝试访问该请求的上游服务器接收到无效响应。
- 504 `Gateway Timeout`：服务器在充当网关或代理时，没有及时收到上游服务器的响应。

参考资料

- [HTTP 灵魂之问，巩固你的 HTTP 知识体系](https://juejin.cn/post/6844904100035821575)
- [前端进阶高薪必看-HTTPS 篇](https://juejin.cn/post/6844904150115827725)
- [TLS 详解握手流程](https://juejin.cn/post/6895624327896432654)
- [HTTP 史记 - 从 HTTP/1 到 HTTP/3](https://juejin.cn/post/7111507179881889800)
- [HTTP/3 核心概念之 QUIC](https://juejin.cn/post/7140516162613444639)
