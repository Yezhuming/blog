# 计算机网络

## 五层模型

### 物理层

物理层的主要作用是通过光纤、电缆等介质连接计算机，通过高低电频发送 0 和 1 电信号。

### 数据链路层

数据链路层通过制定协议去规定电信号的传输和接收。

#### 以太网协议

以太网协议规定，一组电信号构成一个数据包，称为**帧**。

每一个帧由**标头**和**数据**组成，标头主要是一些说明数据，例如发送者和接收者的相关信息。数据则是发送者想要传输给接收者的数据包。

#### MAC 地址

每一个连入网络的计算机都有一个网卡，每一个网卡都有一个唯一的地址，这个地址就是**MAC 地址**。

MAC 地址由 48 个二进制位组成，在网卡生产时就已经确定了。

#### 广播

向同一子网内的计算机发送同一个数据包，所有接受该数据包的计算机比对 MAC 地址，如果相同则接收，否则丢弃。

### 网络层

#### IP 协议

IP 协议定义的地址称为 IP 地址，IPv4 的地址由 32 位二进制数组成。

IP 地址由两部分组成，分别是网络部分和主机部分，两部分所占用的二进制位数是不固定的。通过**子网掩码**与 IP 地址做与（and）运算可以得出网络部分，当网络部分相同时，即在同一个子网中。

#### ARP 协议

ARP 协议是一个根据 IP 地址获取 MAC 地址的一个 TCP/IP 协议。主机通过广播发送数据包，同一子网内的计算机接收数据包后比对 IP 地址，如果相同则把自己的 MAC 地址回复发送者。

假如两台计算机的 IP 不在同一个子网中，则会把数据包发送到网关，让网关进行转发到别的子网。

**网络层的功能就是建立计算机到计算机的通信。**

### 传输层

传输层的功能就是建立端口到端口的通信。通过端口的准确将数据交给计算机中各种各样的应用程序。

### 应用层

虽然我们收到了传输层传来的数据，可是这些传过来的数据五花八门，有 html 格式的，有 mp4 格式的，各种各样。

因此我们需要指定这些数据的格式规则，收到后才好解读渲染。例如我们最常见的 Http 数据包中，就会指定该数据包是 什么格式的文件了。

参考资料：

- [计算机网络五层模型入门](https://www.iamshuaidi.com/747.html)

## TCP

### 三次握手

握手之前客户端主动打开连接结束 **closed** 状态，服务端被动打开连接结束 **closed** 状态进入 **listen** 状态，然后开始三次握手：

1. 第一次握手：客户端发送一个 **SYN** 报文，并指定一个初始化序列号 a，此时客户端进入 **SYN_SEND** 状态。
2. 第二次握手：服务端收到客户端发送的 **SYN** 报文后，同样发送一个 **SYN** 报文作为应答，并指定一个初始化序列号 b，同时将 a + 1 作为 **ACK** 的值，表示自己已经收到了客户端的报文，此时服务端进入 **SYN_REVD** 状态。
3. 第三次握手：客户端收到服务端的 **SYN** 报文后，发送一个 **ACK** 报文作为应答，将 b + 1 作为 **ACK** 的值，表示已经收到了服务端的报文，此时客户端进入 **established** 状态。

最后服务端收到 **ACK** 报文后也进入 **established** 状态，此时双方建立连接完成。

**Q&A**

1. 为什么不能是两次握手？

防止产生过时或无效的连接。

- 客户端请求报文延迟：客户端发送请求后，由于网络堵塞等原因导致服务端没接收到该报文，此时客户端在规定时间内没有收到服务端的应答报文就会重新发送请求，服务端作出应答后正常建立连接，这时上一个请求报文到达服务端，服务端也会作出应答，导致客户端和服务端再次建立连接，导致不必要的错误和资源的浪费。
- 服务端应答报文丢失：如果只有两次握手，在第二次握手中服务端收到客户端的报文后发送的应答报文丢失了，由于没有第三次握手，服务端也不知道客户端是否收到应答报文，就会一直处于开启状态，而客户端由于没有收到应答报文会再次发送请求，那么服务端就会重新开启一个端口连接，而此时上一个端口一直处于开启状态但是并没有传输数据，就会造成服务端的资源浪费。

2. 报文中的序列号是固定的吗？

序列号的作用是让对方知道接下来接收数据的时候如何按照序列号组装数据，如果是固定的则很容易被攻击者猜到后续的确认号，因此序列号是动态生成的。

### 四次挥手

挥手前双方都处于 **established** 状态，当客户端主动发起结束连接请求时，挥手开始：

1. 第一次挥手：客户端发送一个 **FIN** 报文，并指定一个序列号 a，此时客户端处于 **FIN_WAIT1** 状态。
2. 第二次挥手：服务端收到 **FIN** 报文后，发送一个 **ACK** 报文作为应答，并指定 **a + 1** 作为 **ACK** 的值，此时服务端处于 **CLOSE_WAIT** 状态。
3. 第三次挥手：服务端发送一个 **FIN** 报文，并指定一个序列号 b ，此时服务端处于 **LAST_ACK** 阶段。
4. 第四次挥手：客户端收到报文后，同样发送一个 **ACK** 报文作为应答，并指定 **b + 1** 作为 **ACK** 的值，然后进入 **TIME_WAIT** 阶段，等待 **2MSL** 阶段后进入 **CLOSED** 阶段。

服务端收到 **ACK** 报文后就进入 **CLOSED** 状态，结束连接。

**Q&A**

1. 为什么 TIME_WAIT 状态要持续 2MSL？

MSL（Maximum Segment Lifetime）是最大报文生存时间，即报文在网络传输时的超时时间，超时的报文会被丢弃。

TIME_WAIT 状态要持续 2MSL 是因为在第四次挥手中客户端发送 ACK 报文后，如果服务端在第一个 MSL 没收到 ACK 报文，就会重新发送 FIN 报文，第二个 MSL 则是 FIN 报文到达客户端的最长时间，如果在这个时间内客户端没有收到 FIN 报文，表示服务端已经收到客户端的 ACK 报文。

参考资料：

- [三次握手与四次挥手](https://juejin.cn/post/6844903834708344840)

## HTTP

### HTTP 各版本特点

#### HTTP 1.0

- 无状态、无连接（1.1 解决）
- 队头阻塞（2.0 解决）

**http 层队头阻塞**

队头阻塞是指服务端的每个响应必须得按顺序返回，一个体积很大的响应会阻塞后续所有相应的返回。在 http 2.0 通过多路复用解决了，但是仍然存在 TCP 层的队头阻塞。

**TCP 层队头阻塞**

当传输时其中一个数据包丢失后，TCP 层会发生阻塞并进行数据重传。

#### HTTP 1.1

- 持久连接（Connection: keep-alive）
- 请求管道化
- 增加缓存处理（cache-control）
- 增加 Host 字段
- 断点传输（range）

**请求管道化**

请求管道化即不需要等待上一个请求响应后再发送请求，但是响应还是会按照请求顺序返回，所以并没有解决队头阻塞问题。

**Host 字段**

用来指定服务器域名，有了 Host 字段，再同一台服务器上就可以搭建多个网站。

#### HTTP 2.0

- 二进制分帧
- 多路复用（一个 TCP 连接可以进行任意数量的 HTTP 请求）
- 头部压缩
- 服务器推送

**多路复用**

多路复用是基于流传输的，一个完整的请求或响应称为一个消息，每个消息都被拆分成若干帧（`frame`）进行传输，每个帧在传输时属于一个流（`stream`），而一个连接中可以存在多个流，各个帧在流和连接上独立传输，到达之后再组装成消息。

**服务器推送**

在浏览器刚请求 `html` 时，服务器可以将关联的 `js`、`css` 等静态资源主动发送给客户端，这样客户端就可以直接从本地加载这些资源，不用再向服务器发送请求。

## https

## 状态码

**2xx 响应成功**

- 200： OK

**重定向 3xx**

- 301 `Moved Permanently`（永久移动）：所请求的资源被永久的移动到一个新的 URI 上，新的 URI 会在响应头的 Location 中提供。
- 302 `Founded`（临时移动）：所请求的资源被临时移动到新的 URI 上，后续可能还会被移动。
- 304 `Not Modified`（未修改）：资源未发生改变，要求客户端使用缓存资源。

**客户端错误 4xx**

- 400 `Bad Request`（错误请求）：请求语法格式错误，服务器无法处理该请求
- 401 `Unauthorized`（未授权）：该请求需要用户验证。
- 403 `Forbidden`（禁止访问）：服务器拒绝执行该请求。
- 404 `Not Found`（未找到）：服务器未找到请求的资源。
- 405 `Method Not Allowed`（方法不允许）：所请求的资源不允许使用当前的请求方法。

**服务器错误 5xx**

- 500 `Interval Server Error`：服务器在响应请求时发生错误。
- 502 `Bad Gateway`：服务器在充当网关或代理时，尝试访问该请求的上游服务器接收到无效响应。
- 504 `Gateway Timeout`：服务器在充当网关或代理时，没有及时收到上游服务器的响应。
